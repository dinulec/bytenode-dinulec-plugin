'use strict';
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.BytenodeWebpackPlugin = void 0;
const module_1 = __importDefault(require('module'));
const path_1 = __importDefault(require('path'));
const v8_1 = __importDefault(require('v8'));
const bytenode_1 = require('bytenode-dinulec');
const webpack_1 = require('webpack');
const webpack_virtual_modules_1 = __importDefault(require('webpack-virtual-modules'));
const loader_1 = require('./loader');
const paths_1 = require('./paths');
v8_1.default.setFlagsFromString('--no-lazy');
class BytenodeWebpackPlugin {
  constructor(options = {}) {
    this.name = 'BytenodeWebpackPlugin';
    this.options = {
      compileAsModule: true,
      compileForElectron: false,
      debugLifecycle: false,
      debugLogs: false,
      keepSource: false,
      preventSourceMaps: true,
      silent: false,
      ...options,
    };
  }
  apply(compiler) {
    this.setupLifecycleLogging(compiler);
    this.debug('original options', {
      context: compiler.options.context,
      devtool: compiler.options.devtool,
      entry: compiler.options.entry,
      output: compiler.options.output,
    });
    const { entry, entryLoaders, externals, output, virtualModules } = this.processOptions(compiler.options);
    this.debug('processed options', {
      entry,
      entryLoaders,
      output,
      virtualModules,
    });
    compiler.options.entry = entry;
    compiler.options.output.filename = output.filename;
    if (this.options.preventSourceMaps) {
      this.log('Preventing source maps from being generated by changing "devtool" to false.');
      compiler.options.devtool = false;
    }
    new webpack_1.ExternalsPlugin('commonjs', externals).apply(compiler);
    new webpack_virtual_modules_1.default(virtualModules).apply(compiler);
    this.debug('modified options', {
      devtool: compiler.options.devtool,
      entry: compiler.options.entry,
      output: compiler.options.output,
    });
    compiler.hooks.emit.tapPromise(this.name, async (compilation) => {
      const entryLoaderFiles = [];
      for (const entryLoader of entryLoaders) {
        const entryPoints = compilation.entrypoints;
        const entryPoint = entryPoints.get(entryLoader);
        const files = entryPoint?.getFiles() ?? [];
        entryLoaderFiles.push(...files);
      }
      const outputExtensionRegex = new RegExp('\\' + output.extension + '$', 'i');
      const shouldCompile = (name) => {
        return outputExtensionRegex.test(name) && !entryLoaderFiles.includes(name);
      };
      for (const [name, asset] of Object.entries(compilation.assets)) {
        this.debug('emitting', name);
        if (!shouldCompile(name)) {
          continue;
        }
        let source = asset.source();
        if (this.options.compileAsModule) {
          source = module_1.default.wrap(source);
        }
        const compiledAssetName = name.replace(outputExtensionRegex, '.jsc');
        this.debug('compiling to', compiledAssetName);
        const compiledAssetSource = this.options.compileForElectron
          ? await bytenode_1.compileElectronCode(source)
          : await bytenode_1.compileCode(source);
        compilation.assets[compiledAssetName] = {
          size: () => compiledAssetSource.length,
          source: () => compiledAssetSource,
        };
        if (!this.options.keepSource) {
          delete compilation.assets[name];
        }
      }
    });
  }
  processOptions(options) {
    const output = this.preprocessOutput(options);
    const entries = [];
    const entryLoaders = [];
    const externals = [];
    const virtualModules = [];
    for (const { entry, compiled, loader } of this.preprocessEntry(options)) {
      const entryName = output.name ?? entry.name;
      entries.push([entryName, loader.locations.map((e) => e.location)]);
      entryLoaders.push(entryName);
      const { name } = compiled;
      const from = output.of(entryName);
      const to = output.of(name);
      let relativeImportPath = paths_1.toRelativeImportPath(options.output.path, from, to);
      if (options.target === 'electron-renderer' && options.mode === 'development') {
        relativeImportPath = path_1.default.resolve(options.output.path, 'renderer', relativeImportPath);
      }
      entries.push([name, entry.locations.map((e) => e.location)]);
      externals.push(relativeImportPath);
      for (const e of loader.locations) {
        if (!e.dependency) {
          virtualModules.push([e.location, loader_1.createLoaderCode(relativeImportPath)]);
        }
      }
    }
    return {
      entry: Object.fromEntries(entries),
      entryLoaders,
      externals,
      output,
      virtualModules: Object.fromEntries(virtualModules),
    };
  }
  preprocessOutput({ context, output }) {
    let filename = output?.filename ?? '[name].js';
    const { extension, name } = prepare(context, filename);
    const dynamic = /.*[[\]]+.*/.test(filename);
    filename = dynamic ? filename : '[name]' + extension;
    return {
      dynamic,
      extension,
      filename,
      name: dynamic ? undefined : name,
      of: (name) => filename.replace('[name]', name),
    };
  }
  preprocessEntry({ context, entry }) {
    let entries;
    if (typeof entry === 'function') {
      throw new Error('Entry as a function is not supported as of yet.');
    }
    if (typeof entry === 'string' || Array.isArray(entry)) {
      entries = [[undefined, entry]];
    } else {
      entries = Object.entries(entry);
    }
    return entries.map(([name, location]) => {
      const entry = prepare(context, location, name);
      const compiled = prepare(context, location, name, '.compiled');
      const loader = prepare(context, location, name, '.loader');
      return {
        compiled,
        entry,
        loader,
      };
    });
  }
  debug(title, data, ...rest) {
    const { debugLogs, silent } = this.options;
    if (!debugLogs || silent) {
      return;
    }
    if (typeof data === 'object') {
      console.debug('');
      if (typeof title === 'string') {
        title = title.endsWith(':') ? title : `${title}:`;
      }
    }
    console.debug(title, data, ...rest);
  }
  log(...messages) {
    if (this.options.silent) {
      return;
    }
    console.log(`[${this.name}]:`, ...messages);
  }
  setupLifecycleLogging(compiler) {
    const { debugLifecycle, silent } = this.options;
    if (!debugLifecycle || silent) {
      return;
    }
    setupHooksLogging(this.name, 'compiler', compiler.hooks);
    compiler.hooks.normalModuleFactory.tap(this.name, (normalModuleFactory) => {
      setupHooksLogging(this.name, 'normalModuleFactory', normalModuleFactory.hooks);
    });
    compiler.hooks.compilation.tap(this.name, (compilation) => {
      setupHooksLogging(this.name, 'compilation', compilation.hooks);
    });
    function setupHooksLogging(pluginName, type, hooks) {
      for (const [name, hook] of Object.entries(hooks)) {
        try {
          hook.tap(pluginName, function () {
            console.debug(`[${pluginName}]: ${type} hook: ${name} (${arguments.length} arguments)`);
          });
        } catch (_) {}
      }
    }
  }
}
exports.BytenodeWebpackPlugin = BytenodeWebpackPlugin;
function prepare(context, location, name, suffix = '') {
  const locationArray = Array.isArray(location) ? location : [location];
  const locations = locationArray.map((location) => {
    const dependency = isDependency(location);
    if (dependency) {
      return {
        dependency,
        location,
      };
    }
    if (context && !path_1.default.isAbsolute(location)) {
      location = path_1.default.resolve(context, location);
    }
    const directory = path_1.default.dirname(location);
    const extension = path_1.default.extname(location);
    const basename = path_1.default.basename(location, extension) + suffix;
    const filename = basename + extension;
    location = path_1.default.join(directory, filename);
    return {
      basename,
      dependency,
      location,
    };
  });
  let basename = 'main' + suffix;
  if (locations.length === 1) {
    const [single] = locations;
    basename = single.basename ?? basename;
  }
  name = name ? name + suffix : basename;
  return {
    extension: '.js',
    locations,
    name,
  };
  function isDependency(module) {
    if (path_1.default.isAbsolute(module) || /^[.]+\/.*/.test(module)) {
      return false;
    }
    try {
      return typeof require.resolve(module) === 'string';
    } catch (_) {
      return false;
    }
  }
}
//# sourceMappingURL=index.js.map
